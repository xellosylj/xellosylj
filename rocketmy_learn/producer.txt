创建一个DefaultMQProducer，procuder内部创建一个DefaultMQProducerImpl，所有的操作都委托给DefaultMQProducerImpl

DefaultMQProducerImpl内部有一个procuder的引用 -> defaultMQProducer
启动 -> producer.start -> 委托给DefaultMQProducerImpl.start
如果状态表示serviceState不是create_just，抛出异常
创建mQClientFactory，通过MQClientManager单例来创建，一个应用一个cliendid只创建一个MQClientInstance


通过mQClientFactory注册producer -> registerProducer(groupname,DefaultMQProducerImpl)
    将groupname和DefaultMQProducerImpl放入到producerTable中取，如果已经有了，则注册失败
新创建一个TopicPublishInfo放入到topicPublishInfoTable中
启动mQClientFactory.start
如果producer没有定义namesrvAddr，则根据系统参数rocketmq.namesrv.domain为ip(默认是jmenv.tbsite.net)，如果没有端口号，默认8080，rocketmq.namesrv.domain.subgroup为子目录(默认是nsaddr)去请求， url为http://(rocketmq.namesrv.domain:8080)/rocketmq/(rocketmq.namesrv.domain.subgroup)去请求addr
启动mQClientAPIImpl.start -> 委托给remotingClient.start
	remotingClient.start -> 配置netty的bootstrap，暂时不启动,启动一个周期任务扫描结果列表，移除超时的请求，调用其回调函数
启动一批周期任务startScheduledTask ->
   1.如果namesrvAddr为空，根据上面的规则去请求addr
   2.根据所有consumer和producer的topic去请求routeinfo，根据routeinfo是否变化或者producer和comsumer决定是否更新topicinfo的信息
   3.将不在线的broker去掉，发送心跳到在线的broker
   4.persistAllConsumerOffset
   5.调整消费者线程池大小
   6.启动拉取消息服务，主要是consumer -> pullMessageService.start -> 启动线程，pullRequestQueue.take阻塞，直到有消息返回
     根据返回的pullRequest获取consumerGroup，选择Consumer，没有匹配的consumer，消息被丢弃
     如果有匹配的consumer，使用consumer来处理
   7.启动负载均衡服务，每次按照间隔时间来等待，间隔时间rocketmq.client.rebalance.waitInterval，默认为20秒
     遍历consumer，dorebalance
   8.启动内部创建的defaultMQProducer，group组为"CLIENT_INNER_PRODUCER"
       
创建一个message，可以使用topic，tags，keys，flag，waitStoreMsgOK

发送消息到mq， producer.send
send有多种重载的方法
      1.send(Message msg)  -> send(msg,defaultTimeOut)
  2.send(Message msg,long timeout)  -> sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);
  3.send(Message msg, MessageQueue mq)  -> send(msg,mq,defaultTimeOut)
  4.send(Message msg, MessageQueue mq, long timeout) -> sendKernelImpl(msg, mq, CommunicationMode.SYNC, null, null, timeout);
  5.send(Message msg, MessageQueue mq, SendCallback sendCallback) -> send(msg, mq, sendCallback, defaultTimeOut)
  6.send(Message msg, MessageQueueSelector selector, Object arg)  -> send(msg, selector, arg, defaultTimeOut);
  7.send(Message msg, MessageQueueSelector selector, Object arg, long timeout) -> sendSelectImpl(msg, selector, arg, CommunicationMode.SYNC, null, timeout);
  8.send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback) -> send(msg, selector, arg, sendCallback, defaultTimeOut);
  9.send(Message msg,SendCallback sendCallback) -> sendDefaultImpl(msg, CommunicationMode.ASYNC, sendCallback, timeout - costTime);

sendDefaultImpl (msg,CommunicationMode,sendCallback,timeout)
1.检查message
2.找到topic对应的topicPublishInfo -> tryToFindTopicPublishInfo(topic)
3.如果是同步模式，总次数为重试次数+1，否则为1
4.选择一个消息队列mq，第一次直接选择，并记录选择的mq的brokerName，下次重新选择的时候过滤此mq
5.调用sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout)

sendSelectImpl(msg, selector, arg, CommunicationMode.SYNC, null, timeout)
1.根据topic获取对应的topicPublishInfo
2.使用selector获取消息队列mq
3.调用sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout)

sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout)
1.获取broker地址,如果地址为空，获取topicPublishInfo之后再次获取地址
2.如果是批量消息，设置唯一id
3.如果不是批量消息且消息body大小大于预设的压缩大小，压缩消息body
4.检查禁止列表  -> 猜测是通过跑出异常来打断
5.如果有messageHook，在发送消息之前和之后调用
6.组装requestHeader
7.调用mQClientAPIImpl.sendMessage发送
         如果是异步模式，sendMessage(brokerAddr,mq.getBrokerName(),tmpMessage,requestHeader,timeout-                      costTimeAsync,communicationMode,sendCallback,topicPublishInfo,this.mQClientFactory,this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),context,this)
         如果是同步或者oneway，sendMessage(brokerAddr,mq.getBrokerName(),msg,requestHeader,timeout - costTimeSync,communicationMode,null,null,null,null,context,this)

